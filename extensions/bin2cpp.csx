/*---------------------------------------------------------------------------------------------------------

	Kombine Bin2cpp Extension

	It generates one or more .cpp files with the content of the input file as a byte array, so it 
	can be included in a C++ project.

	(C) Kollective Networks 2026

---------------------------------------------------------------------------------------------------------*/

// Remember, this is just used for intellisense, nothing else
#r "../out/bin/win-x64/debug/mkb.dll"
using Kltv.Kombine.Api;
using Kltv.Kombine.Types;
using static Kltv.Kombine.Api.Statics;
using static Kltv.Kombine.Api.Tool;
using System.Collections.Generic;

/// <summary>
/// Provides functionality to generate C++ source files from binary input files.
/// </summary>
/// <remarks>The Bin2cpp class offers methods to automate the conversion of binary files into corresponding C++
/// source files, typically for embedding binary data into C++ projects. It includes utilities to determine whether
/// files require processing based on their modification times and existence. This class is intended for use in build
/// processes or tooling scenarios where binary resources need to be represented as C++ arrays.
/// </remarks>
public class Bin2cpp {

	/// <summary>
	/// Holds all the symbols generated during the process, with the key being the symbol name 
	/// and the value being the variable name. This can be used for 
	/// for referencing the generated symbols in other parts of the build process.
	/// 
	/// As example, generate an additional header file declaring the symbols
	/// </summary>
	public Dictionary<string, string> Symbols { get; private set; } = new Dictionary<string, string>();


	/// <summary>
	/// Generates all the cpp files to the output files.
	/// </summary>
	/// <param name="bin">List of input binary files</param>
	/// <param name="cpp">List of output cpp files</param>
	/// <returns>true if everything fine. False otherwise.</returns>
	public bool Generate(KList bin,KList cpp) {
		// Clear the symbol table before processing
		Symbols.Clear();
		// First compare if the number of input files matches the number of output files
		if (bin.Count() != cpp.Count()) {
			Msg.PrintError("Bin2cpp: The number of input binary files must match the number of output cpp files.");
			return false;
		}
		// Create the output folder(s)
		KList folders = cpp.AsFolders();
		Folders.Create(folders);
		// Now we can generate the cpp files only for the ones that are missing or outdated
		for (int i = 0; i < bin.Count(); i++) {
			string binFile = bin[i];
			string cppFile = cpp[i];
			Msg.PrintTask($"Bin2cpp: Processing {binFile}:");
			// We generate a variable name and a friendly name for the file,
			// and we store it in the symbol table for later use
			// because we want to have the symbols available for all files, even the ones that are not processed
			string varName = GetVarName(binFile);
			string friendlyName = GetFriendlyName(binFile);
			Symbols.Add(friendlyName, varName);
			// Check if the file should be processed
			if (ShouldProcess(binFile, cppFile) == false) {
				Msg.PrintTaskSuccess(" No changes. Skipping.");
				continue;
			}
			// Generate the cpp file
			try {
				byte[] data = File.ReadAllBytes(binFile);
				using (StreamWriter writer = new StreamWriter(cppFile)) {
					writer.WriteLine("// This file is generated by Bin2cpp extension. Do not edit manually.");
					writer.WriteLine($"// Source binary file: {binFile}");
					writer.WriteLine();
					writer.WriteLine();
					writer.WriteLine($"const unsigned char {varName}[] = {{");
					for (int j = 0; j < data.Length; j++) {
						writer.Write($"0x{data[j]:X2}");
						if (j < data.Length - 1) writer.Write(", ");
						if ((j + 1) % 16 == 0) writer.WriteLine();
					}
					writer.WriteLine();
					writer.WriteLine("};");
					writer.WriteLine();
					writer.WriteLine($"const size_t {varName}_size = sizeof({Path.GetFileNameWithoutExtension(cppFile)});");
				}
				Msg.PrintTaskSuccess(" Generated successfully.");
			} catch (Exception ex) {
				Msg.PrintTaskError(" Failed to generate: "+ex.Message);
				return false;
			}
		}
		return true;
	}

	/// <summary>
	/// Generates all the binary data into a single cpp file.
	/// </summary>
	/// <param name="bin">List of input binary files</param>
	/// <param name="cpp">Single output cpp file</param>
	/// <returns>true if everything fine. False otherwise.</returns>
	public bool Generate(KList bin, KValue cpp) {
		// Clear the symbol table before processing
		Symbols.Clear();
		// Check if the output file should be processed (based on the newest input file)
		bool shouldProcess = false;
		// If destination file does not exist, we should process
		//
		if (Files.Exists(cpp) == false) {
			Msg.Print($"Bin2cpp: Output file {cpp} does not exist. It will be processed.", Msg.LogLevels.Verbose);
			shouldProcess = true;
		} else {
			Msg.Print($"Bin2cpp: Output file {cpp} exists. Checking for changes...", Msg.LogLevels.Verbose);
			long dsttime = Files.GetModifiedTime(cpp);
			foreach (KValue binFile in bin) {
				if (Files.Exists(binFile) == false) {
					Msg.PrintAndAbort("Bin2cpp: Source file " + binFile + " sent to be processed is not found.");
					return false;
				}
				long modTime = Files.GetModifiedTime(binFile);
				if (modTime > dsttime) {
					Msg.Print($"Bin2cpp: Source {binFile} is newer than destination. It will be processed.", Msg.LogLevels.Verbose);
					shouldProcess = true;
					break;
				}
			}
		}
		// Create the symbol table even if we do not need to process,
		// because we want to have the symbols available for all files, even the ones that are not processed
		foreach (KValue binFile in bin) {
			string varName = GetVarName(binFile);
			string friendlyName = GetFriendlyName(binFile);
			Symbols.Add(friendlyName, varName);
		}
		Msg.PrintTask($"Bin2cpp: Processing {cpp}:");
		if (!shouldProcess) {
			Msg.PrintTaskSuccess($"Bin2cpp: No changes for {cpp}. Skipping.");
			return true;
		}
		// Create the output folder(s)
		KValue folders = cpp.AsFolder();
		Folders.Create(folders);
		// Generate the single cpp file
		try {
			using (StreamWriter writer = new StreamWriter(cpp)) {
				writer.WriteLine("// This file is generated by Bin2cpp extension. Do not edit manually.");
				writer.WriteLine("// Source binary files:");
				foreach (KValue binFile in bin) {
					writer.WriteLine($"//   {binFile}");
				}
				writer.WriteLine();
				writer.WriteLine();
				foreach (KValue binFile in bin) {
					byte[] data = File.ReadAllBytes(binFile);
					string arrayName = GetVarName(binFile);
					writer.WriteLine($"const unsigned char {arrayName}[] = {{");
					for (int j = 0; j < data.Length; j++) {
						writer.Write($"0x{data[j]:X2}");
						if (j < data.Length - 1) writer.Write(", ");
						if ((j + 1) % 16 == 0) writer.WriteLine();
					}
					writer.WriteLine();
					writer.WriteLine("};");
					writer.WriteLine();
					writer.WriteLine($"const size_t {arrayName}_size = sizeof({arrayName});");
					writer.WriteLine();
				}
			}
			Msg.PrintTaskSuccess($"Bin2cpp: Generated {cpp} successfully.");
		} catch (Exception ex) {
			Msg.PrintTaskError(" Failed to generate: " + ex.Message);
			return false;
		}
		return true;
	}

	/// <summary>
	/// Returns a valid C++ variable name for the given file path. It replaces dots and dashes with underscores and 
	/// appends a hash of the file path to ensure uniqueness.
	/// </summary>
	/// <param name="filePath"></param>
	/// <returns></returns>
	private string GetVarName(KValue filePath) {
		string varname = "var" + Path.GetFileName(filePath).Replace('.', '_').Replace('-', '_');
		string objectname = filePath.GetHashCode64().ToString();
		return varname + objectname;

	}

	/// <summary>
	/// Returns a friendly name for the file path, which can be used as a resource name or similar. 
	/// It replaces slashes with dots and converts to lower case.
	/// </summary>
	/// <param name="filePath"></param>
	/// <returns></returns>
	private string GetFriendlyName(string filePath) {
		return filePath.Replace('/', '.').Replace('\\', '.').ToLower();
	}

	/// <summary>
	/// Checks if the file should be processed
	/// </summary>
	/// <param name="src">Source file</param>
	/// <param name="dest">Destination file</param>
	/// <returns>True if should be processed. False otherwise</returns>
	static private bool ShouldProcess(KValue src, KValue dest) {
		// Check if the source file exists
		if (Files.Exists(src) == false) {
			// This will exit this build process with error
			Msg.PrintAndAbort("Bin2cpp: Source file " + src + " sent to be processed is not found.");
			return false;
		}
		// Check if the destination file exists. If not exists, it should be built
		if (Files.Exists(dest) == false) {
			Msg.Print("Bin2cpp: File " + dest + " does not exists. It will be processed.", Msg.LogLevels.Verbose);
			return true;
		}
		// Does not exists, so, check for the source file only
		if (Files.GetModifiedTime(src) > Files.GetModifiedTime(dest)) {
			// source file is newer than the object file. If its newer, we need to rebuild
			Msg.Print($"Bin2cpp: Source {src} newer than destination. It will be processed.", Msg.LogLevels.Verbose);
			return true;
		}
		// No dependencies file, source file is older, do not process
		Msg.Print($"Bin2cpp: Source {src} older than destination. No Process.", Msg.LogLevels.Verbose);
		return false;
	}

}
