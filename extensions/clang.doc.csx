/*---------------------------------------------------------------------------------------------------------

	Kombine Clang Doc Extension

	It generates markdown files from clang-doc using the yaml files generated by clang-doc

	(C) Kollective Networks 2022

---------------------------------------------------------------------------------------------------------*/

using Kltv.Kombine.Api;
using System.Linq;
using System.Text;
using System.Collections.Generic;

class ClangDocs {

	class ClangDocFile {

		public ClangDocFile() {
			Name = String.Empty;
			NamespacePath = String.Empty;
			FilenamePath = String.Empty;
			Type = String.Empty;
			File = String.Empty;
			Line = String.Empty;
			Document = null;
			Documentation = String.Empty;
			Save = false;
		}
		//
		// Name of the class / namespace / struct
		//
		public string Name;
		//
		// Namespace path (in form of "namespace::namespace::namespace")
		//
		public string NamespacePath;
		//
		// Filename path where the documentation will be stored (in form of "doc/namespace/class.md")
		//
		public string FilenamePath;
		//
		// Type of the object (Class, Struct, Namespace, etc)
		//
		public string Type;
		//
		// File where the object is defined
		//
		public string File;
		//
		// Line number where the object is defined
		//
		public string Line;
		//
		// The document object itself
		//
		public Yaml.YamlObject? Document;
		//
		// Generated documentation
		//
		public string Documentation;

		//
		// If the document should be saved to disk
		//
		public bool Save;

	}

	//
	// Symbol entry to store the information about a symbol
	// to resolve paths in the documentationc
	//
	//
	private class symbolEntry {
		public symbolEntry() {
			Name = String.Empty;
			USR = String.Empty;
			Path = String.Empty;
			Type = String.Empty;
			File = String.Empty;
			Line = String.Empty;
			NamespacePath = String.Empty;
			Filename = String.Empty;
			Document = null;
			Parent = null;
		}

		public string Name;
		public string USR;
		public string Path;
		public string Type;
		public string File;
		public string Line;
		public string NamespacePath;
		public string Filename;
		public ClangDocFile? Parent;
		public Yaml.YamlObject? Document;
	}

	//
	// Output folder for the documentation
	//
	public static string OutputFolder = String.Empty;

	//
	// Paths to include in the documentation
	//
	public static string[] Paths = Array.Empty<string>();

	//
	// Namespaces to include in the documentation
	//
	public static string[] Namespaces = Array.Empty<string>();

	//
	// Image to include in the header of each documentation file
	//
	public static string ImagePath = String.Empty;

	//
	// Text to be used in the header
	//
	public static string HeaderText = String.Empty;

	//
	// Text to be used in the footer
	//
	public static string FooterText = String.Empty;

	//
	// Project name to be used in the header
	//
	public static string ProjectName = String.Empty;

	//
	// Temporal folder to store the yaml files
	//
	public static string TemporalFolder = String.Empty;

	//
	// If we want only public members documentation
	//
	public static bool OnlyPublic = true;

	//
	// Source list to parse / compile to generate the documentation
	//
	public static KList SourceFiles = new KList();

	//
	// Include paths to be used in the clang-doc command
	//
	public static string[] IncludePaths = Array.Empty<string>();

	//
	// Extra arguments to be used in the clang-doc command
	//
	public static string[] ExtraArguments = Array.Empty<string>();

	//
	// Filename of the image to include in the documentation in any
	//
	static string? image = null;

	//
	// Dictionary of files & objects to compose the documentation
	//
	static private List<ClangDocFile> docFiles = new List<ClangDocFile>();

	//
	// A dictionary of all the symbols found by ID (USR)
	//
	static private Dictionary<string, symbolEntry> symbolsByID = new Dictionary<string, symbolEntry>();

	//
	// Auxiliary dictionary to store the types found in the function enumerateDebug
	// Useful to detect missing information we're not parsing / adding into the documents
	//
	static Dictionary<string, string> classRecords = new Dictionary<string, string>();

	//
	// Generate the documentation
	//
	// TODO: Return false in case the process was not successful totally
	//
	static public bool Generate() {
		//
		// Delete the temporal folder so we ensure we "regenerate"
		//
		if (Directory.Exists(TemporalFolder)) {
			Directory.Delete(TemporalFolder, true);
		}
		Directory.CreateDirectory(TemporalFolder);
		// Prepare the arguments for the clang tool
		//
		KList argst = new KList();
		argst = $" --project-name=\"{ProjectName}\"";
		argst += $" --output={TemporalFolder}";
		argst += " --format=yaml";
		if (OnlyPublic == true)
			argst += " --public";
		foreach(string include in IncludePaths){
			argst += " --extra-arg=-I" + include;
		}
		foreach(string extra in ExtraArguments){
			argst += " --extra-arg=" + extra;
		}
		argst += "--source-root=/";
		argst += "--ignore-map-errors";
		argst += " ";
		argst += SourceFiles.Flatten();
		Tool tool = new Tool("clang-doc");
		Msg.PrintTask("Generating clang-doc documentation: ");
		//
		// Check if we need to use response file
		//
		ToolResult res;
		string args = argst.Flatten();
		if (args.Length > 32766) {
			string responseFile = TemporalFolder + "/clang-doc.rsp";
			// We need to use a response file
			Files.WriteTextFile(responseFile,args);
			string fileargs = "@" + responseFile;
			// Execute the command
			res = tool.CommandSync("clang-doc", fileargs, null);
			// Delete the response file
			if (File.Exists(responseFile)) {
				File.Delete(responseFile);
				Msg.Print($"Response file deleted: {responseFile}");
			}
		} else{
			res = tool.CommandSync("clang-doc", argst.Flatten(), null);
		}
		if (res.ExitCode != 0) {
			Msg.PrintTaskError(" Failed");
			Msg.PrintWarning("Error launching clang-doc to generate documentation.");
			return false;
		}
		Msg.PrintTaskSuccess(" Done");
		//
		// Load the generated files
		//
		Msg.PrintTask("Registering files: ");
		foreach (string file in Directory.GetFiles(TemporalFolder)) {
			var document = Yaml.LoadFile(file);
			if (document == null) {
				continue;
			}
			registerTypes(document);
		}
		Msg.PrintTaskSuccess(" Done");
		//
		// Since some symbols can be defined once we parse the namespace
		// or the class we need to take a two pass aproach (like on linkers)
		// to resolve everything
		//
		//
		// Now we generate the documentation (first step)
		// to resolve all symbols
		//
		Msg.PrintTask("Generating documentation (pass 1/2): ");
		for (int i = 0; i != docFiles.Count; i++) {
			generateMarkdown(docFiles[i]);
		}
		Msg.PrintTaskSuccess(" Done");
		//
		// Now we generate the documentation (second step)
		// to set the links on the files
		//
		Msg.PrintTask("Generating documentation (pass 2/2): ");
		for (int i = 0; i != docFiles.Count; i++) {
			docFiles[i].Documentation = generateMarkdown(docFiles[i]);
		}
		Msg.PrintTaskSuccess(" Done");
		//
		// And finally write the file to disk if needed
		//
		Msg.Print("Saving files: ");
		Msg.BeginIndent();
		for (int i = 0; i != docFiles.Count; i++) {
			if (docFiles[i].Save == true) {
				Msg.PrintTask("Saving " + docFiles[i].FilenamePath + " ...");
				saveDocument(docFiles[i]);
				Msg.PrintTaskSuccess(" Done");
			}
		}
		Msg.EndIndent();
		Msg.Print("Documentation generated successfully.");
		return true;
	}

	//
	// Generate a filename for a given path and object name
	//
	static private string genFilename(string path, string name) {
		//
		// Generate the output path and filename
		// We will use a folder structure following the namespaces
		// Namespace comes with backslashes, we need to normalize to compose the path
		//
		//
		string pathfixed = path.Replace("\\", "/");
		// And the output filename will be the output folder + namespace path + name + .md
		//
		string filename = OutputFolder + pathfixed + "/" + name + ".md";
		// In case path is root, we can get two slashes, leave just one
		filename = filename.Replace("//", "/");
		// Set it to lower case (remember, we will use this as weblinks as well, so , case sensitive)
		filename = filename.ToLower();
		return filename;
	}


	//
	// It receives a document and register it in our dictionaries
	// A document may contain several objects inside
	//
	static private void registerTypes(Yaml.YamlObject obj) {
		// We may have document but without objects inside
		if (obj.Value == null) {
			Console.WriteLine("Document without objects");
			return;
		}
		// The document always contains a list of objects
		//
		if (obj.Value is not List<Yaml.YamlObject> list) {
			return;
		}
		//
		// Create ClangDocFile objects. Each yaml file may contain several objects
		// To generate documentation for.
		//
		foreach (Yaml.YamlObject o in list) {
			// Get the object name
			string Name = Yaml.GetPropertyValue(o, "Name");
			// Namespace path this object is on top
			string Path = Yaml.GetPropertyValue(o, "Path");
			// Get the object type
			string Type = Yaml.GetPropertyValue(o, "TagType");
			// Get the USR (unique symbol reference)
			string USR = Yaml.GetPropertyValue(o, "USR");
			//
			// Get the definition location (may be empty in case of namespaces)
			//
			string file = String.Empty;
			string line = String.Empty;
			Yaml.YamlObject? location = Yaml.FindObject(o, "DefLocation", false);
			if (location != null) {
				// Get the filename and line number
				//
				file = Yaml.GetPropertyValue(location, "Filename");
				line = Yaml.GetPropertyValue(location, "LineNumber");
				//
				// Normalize the filename slashes, we use nix format
				//
				file = file.Replace("\\", "/");
			}
			//
			// Now, create the ClangDocFile object as object for which we will generate documentation
			//
			ClangDocs.ClangDocFile doc = new ClangDocFile();
			doc.Name = Name;
			// We use :: instead of backslahses for the namespace path separation
			//
			doc.NamespacePath = Path.Replace("\\", "::");
			// Save the information in the object
			//
			if (Name == String.Empty) {
				// There is no name so since the file cannot remain unnamed use "index" as name
				doc.FilenamePath = genFilename(Path, "index");
			} else {
				doc.FilenamePath = genFilename(Path, Name);
			}
			doc.Type = Type;
			doc.File = file;
			doc.Line = line;
			doc.Document = o;
			docFiles.Add(doc);
			//
			// Save the symbol in the symbols dictionary
			//
			//
			ClangDocs.symbolEntry symbol = new();
			symbol.Name = Name;
			symbol.USR = USR;
			symbol.Path = Path;
			symbol.NamespacePath = doc.NamespacePath;
			symbol.Type = Type;
			symbol.File = file;
			symbol.Line = line;
			symbol.Filename = doc.FilenamePath;
			symbol.Document = o;
			symbol.Parent = doc;
			if (symbolsByID.ContainsKey(USR) == false)
				symbolsByID.Add(USR, symbol);
		}
	}

	//
	// Generate a markdown document for a given file
	// This function prepares the folder, copies the image and writes the file down the filesystem
	//
	static private bool saveDocument(ClangDocFile file) {
		//
		// If document has no content, skip it
		//
		if (file.Documentation == String.Empty) {
			return false;
		}
		//
		// We use the filename path in absolute web format for the root of the repository
		// so to be used in the filesystem we need to remove the first slash because in the filesystem
		// is relative to the root folder of the repository / project.. ie: /doc/namespace/class.md -> doc/namespace/class.md
		//
		string? folder = file.FilenamePath;
		if (folder.StartsWith("/")) {
			folder = folder.Substring(1);
		}
		folder = Path.GetDirectoryName(folder);
		if (folder == null) {
			// The filename path is invalid, we can't get the folder.
			// That may happen because the filename path points to simply "bla.md" which is not
			// right, it should be "doc/bla.md" or similar. OutputFolder is empty, for example.
			return false;
		}
		// Create the folder if required.
		//
		if (!Directory.Exists(folder)) {
			Directory.CreateDirectory(folder);
		}
		// Copy the image if required
		//
		if (ImagePath != String.Empty) {
			// Save the image filename to be used in the markdown for the upcoming file
			//
			image = Path.GetFileName(ImagePath);
			// Save the image in the folder target of this doc.
			//
			if (!File.Exists(Path.Combine(folder, image))) {
				File.Copy(ImagePath, Path.Combine(folder, image));
			}
		}
		// Generate the markdown file and output the file
		//
		string filename = file.FilenamePath;
		// Remove the initial "/" since is only intended for the links in the markdown
		//
		if (filename.StartsWith("/")) {
			filename = filename.Substring(1);
		}
		File.WriteAllText(filename, generateMarkdown(file));
		return true;
	}

	//
	// Generate a markdown document for a given file
	//
	static private string generateMarkdown(ClangDocFile file) {

		//
		// Add the Header (with the optional image)
		//
		StringBuilder sb = new StringBuilder();
		sb.AppendLine(generateHeader());


		if (file.Type == "Class") {
			sb.AppendLine("# Class: " + file.Name);
		} else if (file.Type == "Struct") {
			sb.AppendLine("# Struct: " + file.Name);
		} else if (file.Type == "") {
			if (file.Name == "GlobalNamespace") {
				sb.AppendLine("# Global Namespace");
			} else if (file.Name == String.Empty) {
				sb.AppendLine("# Global Namespace");
			} else {
				sb.AppendLine("# Namespace: " + file.Name);
			}
		} else if (file.Type == "Union") {
			sb.AppendLine("# Union: " + file.Name);
		} else {
			Console.WriteLine("Unknown type: " + file.Type);
			return String.Empty;
		}
		//
		// Namespace beadcrumb, so we can link to the namespace(s)
		//
		sb.AppendLine(generateNamespaceBreadCrumb(file));
		//
		//
		sb.AppendLine();
		sb.AppendLine("## Info");
		// Parses Bases + Parents + Description
		//
		string info = generateClassInfo(file);
		if (info != String.Empty) {
			sb.AppendLine(info);
		}
		// Parses Members
		//
		string members = generateMembersInfo(file.Document);
		if (members != String.Empty) {
			sb.AppendLine(members);
		}
		// Parses ChildFunctions
		//
		string methods = generateMethodsInfo(file.Document);
		if (methods != String.Empty) {
			sb.AppendLine(methods);
		}
		// Parses ChildRecords
		//
		string records = generateRecordsInfo(file.Document);
		if (records != String.Empty) {
			sb.AppendLine(records);
		}
		// Parses ChildEnums
		//
		string enums = generateChildEnums(file.Document,file);
		if (enums != String.Empty) {
			sb.AppendLine(enums);
		}
		string childNamespaces = generateChildNamespaces(file.Document);
		if (childNamespaces != String.Empty) {
			sb.AppendLine(childNamespaces);
		}
		string templates = generateTemplates(file.Document);
		if (templates != String.Empty) {
			sb.AppendLine(templates);
		}

		sb.AppendLine(generateFooter());
		return sb.ToString();
	}

	// ------------------------------------------------------------------------------------------------------------------
	//
	// Main Generators (Class, Struct, Namespace, etc)
	//
	//
	//
	//
	// ------------------------------------------------------------------------------------------------------------------

	//
	// Gnerate the class information
	//
	static private string generateClassInfo(ClangDocFile file) {


		StringBuilder sb = new StringBuilder();
		if ((file.File != String.Empty) && (file.Line != String.Empty)) {
			sb.AppendLine("##### Declared in: ");
			//
			// TODO: If we fix up the clang-doc to generate the path relative to the project
			// we can link to the file and line where the class is defined.
			//
			sb.AppendLine("*"+ file.File + " Line:" + file.Line + "*");
		}
		// Check if we can get more information
		//
		if (file.Document == null) {
			return sb.ToString();
		}
		//
		// All the inherited classes
		//
		Yaml.YamlObject? bases = Yaml.FindObject(file.Document, "Bases", false);
		if ( (bases != null) && (bases.Value is List<Yaml.YamlObject>) ) {
			List<Yaml.YamlObject> list = (List<Yaml.YamlObject>)bases.Value;
			if (list.Count > 0) {
				sb.Append("##### Base classes: ");
				foreach (Yaml.YamlObject obj in list) {
					string name = Yaml.GetPropertyValue(obj, "Name");
					string usr = Yaml.GetPropertyValue(obj, "USR");
					// Check if we can get the file where the base class is defined
					//
					if (usr != String.Empty) {
						symbolsByID.TryGetValue(usr, out symbolEntry? value);
						if (value != null) {
							sb.Append("[" + name + "](" + value.Filename + ") / ");
						} else {
							sb.Append(name + " / ");
						}
					} else {
						sb.Append(name + " / ");
					}
				}
				sb.AppendLine();
			}
		}
		//
		// Inmediate class parents
		//
		Yaml.YamlObject? parent = Yaml.FindObject(file.Document, "Parents", false);
		if ( (parent != null) && (parent.Value is List<Yaml.YamlObject>)) {
			List<Yaml.YamlObject> list = (List<Yaml.YamlObject>)parent.Value;
			if (list.Count > 0) {
				sb.Append("##### Parent classes: ");
				foreach (Yaml.YamlObject obj in list) {
					//
					// Try to get the class to add a reference
					//
					string? USR2 = Yaml.GetPropertyValue(obj, "USR");
					string? Name = Yaml.GetPropertyValue(obj, "Name");
					// If we have USR, use it
					string namespacepath = String.Empty;
					if (USR2 != null) {
						symbolsByID.TryGetValue(USR2, out symbolEntry? value2);
						if (value2 != null)
							namespacepath = value2.Filename;
					}
					if (namespacepath != String.Empty) {
						sb.Append("[" + Name + "](" + namespacepath + ") / ");
					} else {
						sb.Append(Name + " /");
					}
				}
				sb.AppendLine();
			}
		}
		// Description
		Yaml.YamlObject? description = Yaml.FindObject(file.Document, "Description", false);
		if (description != null) {
			string[] text = getDescription(description);
			if (text.Length > 0) {
				sb.AppendLine("##### Description:");
				foreach (string s in text) {
					sb.Append(s);
				}
			}
		}
		return sb.ToString();
	}


	// ------------------------------------------------------------------------------------------------------------------
	//
	// Secondary Generators (Members, Methods, etc)
	//
	//
	//
	//
	// ------------------------------------------------------------------------------------------------------------------

	//
	// Generate the methods information for a class
	// TODO: Let's see if this can work also for namespaces
	//
	private static string generateMethodsInfo(Yaml.YamlObject? obj) {
		List<string> publicMembers = new List<string>();
		List<string> protectedMembers = new List<string>();
		List<string> privateMembers = new List<string>();

		if (obj == null) {
			return string.Empty;
		}

		Yaml.YamlObject? members = Yaml.FindObject(obj, "ChildFunctions", false);
		if (members == null) {
			return string.Empty;
		}
		if (members.Value is not List<Yaml.YamlObject> list) {
			return string.Empty;
		}
		List<Yaml.YamlObject> membersList = (List<Yaml.YamlObject>)members.Value;
		for (int i = 0; i != membersList.Count; i++) {
			Yaml.YamlObject member = membersList[i];
			// USR (if we want to register the member as type)
			string methodUSR = Yaml.GetPropertyValue(member, "USR");
			// Name
			string methodName = Yaml.GetPropertyValue(member, "Name");
			// Namespace it belongs (array)
			// Description
			Yaml.YamlObject? desc = Yaml.FindObject(member,"Description",false);
			string methodDescription = String.Empty;
			if (desc != null) {
				string[] text = getDescription(desc);
				if (text.Length > 0) {
					foreach (string s in text) {
						methodDescription += s;
					}
				}
			}
			// Definition location
			// Location
			// IsMethod
			string IsMethod = Yaml.GetPropertyValue(member,"IsMethod");
			// Parent (classes this method belongs to, include overrides)
			// Params
			// Array of parameters with properties
			string methodParamsCode = String.Empty;
			string methodParamsMD = String.Empty;
			Yaml.YamlObject? parms = Yaml.FindObject(member, "Params", false);
			if ( (parms != null) && (parms.Value is List<Yaml.YamlObject>) ) {
				var parList = (List<Yaml.YamlObject>)parms.Value;
				foreach (Yaml.YamlObject par in parList) {
					string paramName = Yaml.GetPropertyValue(par, "Name");
					string paramTypeCode = String.Empty;
					string paramTypeMD = String.Empty;
					Yaml.YamlObject? type = Yaml.FindObject(par, "Type", false);
					if (type != null) {
						parseType(type, ref paramTypeMD, ref paramTypeCode);
					}
					methodParamsMD += paramTypeMD + " " + paramName + ", ";
					methodParamsCode += paramTypeCode + " " + paramName + ", ";
				}
				// Remove last comma
				if (methodParamsMD != String.Empty) {
					methodParamsMD = methodParamsMD.Substring(0, methodParamsMD.Length - 2);
				}
				if (methodParamsCode != String.Empty) {
					methodParamsCode = methodParamsCode.Substring(0, methodParamsCode.Length - 2);
				}
			}
			// Return type
			string returnTypeCode = String.Empty;
			string returnTypeMd = String.Empty;
			Yaml.YamlObject? returnType = Yaml.FindObject(member, "ReturnType", false);
			if (returnType != null) {
				// We check for null inside the function but to avoid C# warning ...
				Yaml.YamlObject? typeInfo = Yaml.FindObject(returnType, "Type", false);
				parseType(typeInfo, ref returnTypeMd, ref returnTypeCode);
			}
			// Accesss
			string methodAccess = Yaml.GetPropertyValue(member, "Access");

			// Format and add the method into the list
			//
			string methodInfo;
			methodInfo = "### " + returnTypeMd + " " + methodName + "(" + methodParamsMD + ")\r\n";
			if (methodDescription != String.Empty) {
				methodInfo += methodDescription;
			}
			methodInfo += "\n```\n";
			methodInfo += returnTypeCode + " " + methodName + "(" + methodParamsCode + ");\n";
			methodInfo += "```\n";


			// Set the member in the appropriate list
			//
			if (methodAccess == "Public") {
				publicMembers.Add(methodInfo);
			} else if (methodAccess == "Protected") {
				protectedMembers.Add(methodInfo);
			} else if (methodAccess == "Private") {
				privateMembers.Add(methodInfo);
			} else {
				// If no method access, we assume public
				publicMembers.Add(methodInfo);
			}
		}
		string result = String.Empty;
		if (publicMembers.Count > 0) {
			result = "## Public Methods\r\n";
			foreach (string s in publicMembers) {
				result += s;
			}

		}
		if (protectedMembers.Count > 0) {
			result += "## Protected Methods\r\n";
			foreach (string s in protectedMembers) {
				result += s;
			}
		}
		if (privateMembers.Count > 0) {
			result += "## Private Methods\r\n";
			foreach (string s in privateMembers) {
				result += s;
			}
		}
		return result;
	}


	//
	// Generate the members information for a class
	// TODO: Let's see if we can make it work also with namespace members
	//
	private static string generateMembersInfo(Yaml.YamlObject? obj) {
		List<string> publicMembers = new List<string>();
		List<string> protectedMembers = new List<string>();
		List<string> privateMembers = new List<string>();

		if (obj == null) {
			return string.Empty;
		}

		Yaml.YamlObject? members = Yaml.FindObject(obj, "Members", false);
		if (members == null) {
			return string.Empty;
		}
		if (members.Value is not List<Yaml.YamlObject> list) {
			return string.Empty;
		}
		List<Yaml.YamlObject> membersList = (List<Yaml.YamlObject>)members.Value;
		for (int i = 0; i != membersList.Count; i++) {
			Yaml.YamlObject member = membersList[i];
			string memberTypeCode = String.Empty;
			string memberTypeMD = String.Empty;
			string memberDescription = String.Empty;
			string memberAccess = String.Empty;
			string memberName = String.Empty;

			Yaml.YamlObject? type = Yaml.FindObject(member, "Type", false);
			if (type != null) {
				parseType(type, ref memberTypeMD, ref memberTypeCode);
			}

			memberName = Yaml.GetPropertyValue(member, "Name");
			memberAccess = Yaml.GetPropertyValue(member, "Access");
			Yaml.YamlObject? desc = Yaml.FindObject(member, "Description", false);
			if (desc != null) {
				string[] text = getDescription(desc);
				if (text.Length > 0) {
					foreach (string s in text) {
						memberDescription += s;
					}
				}
			}
			string memberInfo = "### " + memberTypeMD + "  " + memberName + "\r\n";
			if (memberDescription != String.Empty) {
				memberInfo += memberDescription + "\r\n";
			}
			if (memberTypeCode != String.Empty) {
				memberInfo += memberTypeCode + " " + memberName + ";\r\n";
			}
			// Set the member in the appropriate list
			//
			if (memberAccess == "Public") {
				publicMembers.Add(memberInfo);
			} else if (memberAccess == "Protected") {
				protectedMembers.Add(memberInfo);
			} else if (memberAccess == "Private") {
				privateMembers.Add(memberInfo);
			}
		}
		//
		// TODO: We can list the members by access level and format here by access level
		//
		string result = String.Empty;
		if (publicMembers.Count > 0) {
			result = "## Public Members\r\n";
			foreach (string s in publicMembers) {
				result += s;
			}
		}
		if (protectedMembers.Count > 0) {
			result += "## Protected Members\r\n";
			foreach (string s in protectedMembers) {
				result += s;
			}
		}
		if (privateMembers.Count > 0) {
			result += "## Private Members\r\n";
			foreach (string s in privateMembers) {
				result += s;
			}
		}
		return result;
	}

	//
	// Generate the records information for a class
	//
	private static string generateRecordsInfo(Yaml.YamlObject? obj) {
		List<string> innerTypes = new List<string>();
		if (obj == null) {
			return string.Empty;
		}

		Yaml.YamlObject? members = Yaml.FindObject(obj, "ChildRecords", false);
		if (members == null) {
			return string.Empty;
		}
		if (members.Value is not List<Yaml.YamlObject> list) {
			return string.Empty;
		}
		List<Yaml.YamlObject> membersList = (List<Yaml.YamlObject>)members.Value;
		for (int i = 0; i != membersList.Count; i++) {
			Yaml.YamlObject member = membersList[i];

			string memberName = Yaml.GetPropertyValue(member, "Name");
			string memberQualName = Yaml.GetPropertyValue(member, "QualName");
			string memberUSR = Yaml.GetPropertyValue(member, "USR");
			//
			// With the USR we can resolve and link where is exactly defined the type
			//
			//
			symbolsByID.TryGetValue(memberUSR, out symbolEntry? value);
			if (value != null) {
				memberName = "[" + memberName + "](" + value.Filename + ")";
			}
			innerTypes.Add("### " + memberName + "\r\n");
		}
		// Generate the output if we had any inner types
		//
		if (innerTypes.Count > 0) {
			string result = "## Inner Types\r\n";
			foreach (string s in innerTypes) {
				result += s;
			}
			return result;
		}
		return string.Empty;
	}

	//
	// Generate the information for the child enums
	// NOTE: It may register the type as well.
	//
	private static string generateChildEnums(Yaml.YamlObject? obj,ClangDocFile doc) {
		List<string> innerEnums = new List<string>();
		if (obj == null) {
			return string.Empty;
		}

		Yaml.YamlObject? members = Yaml.FindObject(obj, "ChildEnums", false);
		if (members == null) {
			return string.Empty;
		}
		if (members.Value is not List<Yaml.YamlObject> list) {
			return string.Empty;
		}
		List<Yaml.YamlObject> membersList = (List<Yaml.YamlObject>)members.Value;
		for (int i = 0; i != membersList.Count; i++) {
			Yaml.YamlObject member = membersList[i];
			//
			// A enum entry has USR, Name, Namespace, Description
			// DefLocation, Scoped, BaseType and Members
			//
			// As a note, USR in this case does not point to a type, is the TYPE of this enum
			// So we can proceed to add this type to be referenced somewhere else
			//
			string memberName = Yaml.GetPropertyValue(member, "Name");
			string memberUSR = Yaml.GetPropertyValue(member, "USR");

			symbolEntry symbol = new symbolEntry();
			symbol.Name = memberName;
			symbol.USR = memberUSR;
			symbol.Path = doc.NamespacePath;
			symbol.Type = "Enum";
			symbol.File = doc.File;
			symbol.Line = doc.Line;
			symbol.Filename = doc.FilenamePath;
			symbol.Document = member;
			symbol.Parent = doc;
			if (symbolsByID.ContainsKey(memberUSR) == false)
				symbolsByID.Add(memberUSR, symbol);


			string memberDescription = String.Empty;
			Yaml.YamlObject? desc = Yaml.FindObject(member, "Description", false);
			if (desc != null) {
				string[] text = getDescription(desc);
				if (text.Length > 0) {
					foreach (string s in text) {
						memberDescription += s;
					}
				}
			}
			string baseType = String.Empty;
			Yaml.YamlObject? bases = Yaml.FindObject(member, "BaseType", false);
			if (bases != null) {
				Yaml.YamlObject? yamlObject = bases.Value as Yaml.YamlObject;
				if (yamlObject != null) {
					baseType = Yaml.GetPropertyValue(yamlObject, "QualName");
				}
			}

			//
			// Fetch the enum members
			//
			string enumList = String.Empty;
			Yaml.YamlObject? enummembers = Yaml.FindObject(member, "Members", false);
			if (enummembers != null) {
				List<Yaml.YamlObject>? enummembersList = (List<Yaml.YamlObject>?)enummembers.Value;
				if (enummembersList != null) {
					foreach (Yaml.YamlObject o in enummembersList) {
						string name = Yaml.GetPropertyValue(o, "Name");
						string value = Yaml.GetPropertyValue(o, "Value");
						//
						// An enumeration member has Name / Value
						// Also "Expr" (not so clear what it express)
						// But looks like lacks description so all the descriptions in the enums
						// are gone?
						//
						enumList += "*" + name + " = " + value + "*\r\n";
					}
				}
			}
			string memberInfo = "### ";
			if (baseType != String.Empty) {
				memberInfo += memberName + "(" + baseType + ")\r\n";
			} else {
				memberInfo += memberName + "\r\n";
			}
			if (memberDescription != String.Empty) {
				memberInfo += memberDescription + "\r\n";
			}
			if (enumList != String.Empty) {
				memberInfo += "#### Members:\r\n";
				memberInfo += enumList;
			}
			//
			// TODO: Generate the type entry for this enum
			//

			innerEnums.Add(memberInfo);

		}
		// Generate the output if we had any inner types
		//
		if (innerEnums.Count > 0) {
			string result = "## Enumerations \r\n";
			foreach (string s in innerEnums) {
				result += s;
			}
			return result;
		}
		return string.Empty;
	}

	//
	// Generate the information for the child namespaces
	//
	private static string generateChildNamespaces(Yaml.YamlObject? obj) {
		List<string> innerEnums = new List<string>();
		if (obj == null) {
			return string.Empty;
		}
		Yaml.YamlObject? members = Yaml.FindObject(obj, "ChildNamespaces", false);
		if (members == null) {
			return string.Empty;
		}
		if (members.Value is not List<Yaml.YamlObject> list) {
			return string.Empty;
		}
		List<Yaml.YamlObject> membersList = (List<Yaml.YamlObject>)members.Value;
		for (int i = 0; i != membersList.Count; i++) {
			Yaml.YamlObject member = membersList[i];
		}
		return string.Empty;
	}

	//
	// Generate the information for the templatized elements
	//
	// Keep it as reference to add code later if required to generate documentation about templates
	//
	private static string generateTemplates(Yaml.YamlObject? obj) {
		List<string> innerEnums = new List<string>();
		if (obj == null) {
			return string.Empty;
		}
		Yaml.YamlObject? members = Yaml.FindObject(obj, "Template", false);
		if (members == null) {
			return string.Empty;
		}
		if (members.Value is not List<Yaml.YamlObject> list) {
			return string.Empty;
		}
		List<Yaml.YamlObject> membersList = (List<Yaml.YamlObject>)members.Value;
		for (int i = 0; i != membersList.Count; i++) {
			Yaml.YamlObject member = membersList[i];
		}
		return string.Empty;
	}


	// ------------------------------------------------------------------------------------------------------------------
	//
	// Auxiliary functions (getDescription, generateNamespaceBreadCrumb, etc)
	//
	//
	//
	//
	// ------------------------------------------------------------------------------------------------------------------

	//
	// Add in a dictionary all the inner definitions of an object
	// useful to debug and check if we're covering everything.
	// Results are stored in the classRecords dictionary to be inspected later on.
	//
	private static void enumerateDebug(Yaml.YamlObject obj) {
		if (obj == null) {
			return;
		}
		List<Yaml.YamlObject>? listR = new List<Yaml.YamlObject>();
		listR = obj.Value as List<Yaml.YamlObject>;
		if (listR == null) {
			return;
		}
		foreach (Yaml.YamlObject objR in listR) {
			if (classRecords.ContainsKey(objR.Key) == false) {
				string? value = objR.Value?.ToString();
				if (value == null)
					value = String.Empty;
				classRecords.Add(objR.Key,value );
			}
		}

	}


	//
	// Returns an array of strings formatted with all the description text values
	//
	// Text is collected "as is".. there is room to improve since we can look for the
	// Paragraph kinds and merge properly the text.
	//
	// Also we need to know what happens if we add parameters documentation in the
	// description, we need to handle that.
	//
	private static string[] getDescription(Yaml.YamlObject obj) {
		List<string> list = new List<string>();
		string text = Yaml.GetPropertyValue(obj, "Text");
		if (text != String.Empty) {
			// Remove new lines and carriage returns
			// We will ensure there is only one per line
			text = text.Replace("\n", "");
			text = text.Replace("\r", "");
			text = sanitizeStringMarkdown(text);
			text = ">*"+text + "*\n";
			list.Add(text);
		}
		string kind = Yaml.GetPropertyValue(obj, "Kind");
		if (kind == "ParagraphComment") {
			list.Add(">\n");
		}
		if (obj.Value is List<Yaml.YamlObject> list2) {
			foreach (Yaml.YamlObject o in list2) {
				string[] result = getDescription(o);
				foreach (string s in result) {
					list.Add(s);
				}
			}
		}
		return list.ToArray();
	}

	//
	// Generate the namespace bread crumb with links if possible
	// Also, when parsing the namespace we:
	// Mark the file as it should be saved and mark the namespaces it belongs
	// to be saved as well
	//
	static private string generateNamespaceBreadCrumb(ClangDocFile doc) {
		//
		// Check if the file should be included in the documentation written to disk
		//
		if (filterByNamespace(doc.NamespacePath, doc.Name) == false) {
			if (filterByFilePath(doc.File) == false) {
				doc.Save = true;
			}
		}
		//
		// Resolve all the different namespaces (we've already the path in :: form)
		//
		string[] parts = doc.NamespacePath.Split("::");
		if (parts.Length == 0) {
			// Do not add namespace beadcrumb if there is no namespace
			return String.Empty;
		}
		StringBuilder sb = new StringBuilder();
		sb.Append("## Namespace: ");
		if (doc.Document == null) {
			sb.Append(doc.NamespacePath);
			return sb.ToString();
		}
		foreach (string part in parts) {
			if (part == String.Empty) {
				sb.Append("[Global]");
				break;
			}
			Yaml.YamlObject? ns = Yaml.FindObject(doc.Document, "Namespace", false);
			string namespacepath = String.Empty;
			if (ns != null) {
				// We get the namespace entries
				// Look for the namespace name
				Yaml.YamlObject? nsInfo = Yaml.FindObjectInList(ns, true, "Name", part);
				if (nsInfo != null) {
					string USR = Yaml.GetPropertyValue(nsInfo, "USR");
					//
					// We've the identifier of the namespace, look for it.
					//
					if (USR != String.Empty) {
						symbolsByID.TryGetValue(USR, out symbolEntry? namespacefile);
						if (namespacefile != null) {
							namespacepath = namespacefile.Filename;
							//
							// We will mark this namespace to be saved as well if this document
							// is saved.
							//
							if ( (doc.Save == true) && (namespacefile.Parent != null) )
								namespacefile.Parent.Save = true;
						}
					}
				}
			}
			if (namespacepath == String.Empty) {
				sb.Append(part + " \\> ");
				continue;
			}
			sb.Append("[" + part + "](" + namespacepath + ") \\> ");
		}
		return sb.ToString();
	}

	//
	// Generate the header of the documentation
	//
	static private string generateHeader() {
		StringBuilder sb = new StringBuilder();
		if (image != null) {
			sb.AppendLine("<img src=\"" + image + "\" style=\"display:block; margin:auto\"/>");
			sb.AppendLine();
		}
		if (HeaderText != String.Empty) {
			sb.AppendLine("*" + HeaderText + "*");
		}
		return sb.ToString();
	}

	//
	// Generate the footer of the documentation
	//
	static private string generateFooter() {
		//
		// [..] Todo, add here a "back to index" or similar if required.
		//
		return FooterText;
	}

	//
	// Parse a type entry.
	// It generates two typenames, one suitable to be used in markdown (escaped characters+links)
	// and other suitable to be used in code (no links, no escaped characters)
	//
	static private void parseType(Yaml.YamlObject? type,ref string typeNameMD,ref string typeNameCode) {
		if (type == null) {
			return;
		}
		string Name = Yaml.GetPropertyValue(type, "Name");
		string Qualname = Yaml.GetPropertyValue(type, "QualName");
		string USR = Yaml.GetPropertyValue(type, "USR");
		string Path = Yaml.GetPropertyValue(type, "Path");
		string Type = Yaml.GetPropertyValue(type, "Type");

		// Fix the bool type
		//
		Name = Name.Replace("_Bool", "bool");
		Qualname = Qualname.Replace("_Bool", "bool");



		string typeInfo = String.Empty;
		if (USR != String.Empty) {
			symbolsByID.TryGetValue(USR, out symbolEntry? memberfile);
			if (memberfile != null) {
				typeInfo = memberfile.Filename;
			} else {
				//Console.WriteLine("Could not fetch type: " + Qualname);
			}
		}

		// Compose the typeNameCode
		//
		string nameCode = String.Empty;
		nameCode = Qualname;
		if (Name != Qualname) {
			nameCode += "(" + Name + ")";
			typeNameCode = nameCode;
		} else {
			typeNameCode = Qualname;
		}
		// Compose the typeNameMD
		//
		Name = sanitizeStringMarkdown(Name);
		Qualname = sanitizeStringMarkdown(Qualname);
		if (typeInfo != String.Empty) {
			typeNameMD = "[" + Qualname + "](" + typeInfo + ")";
		} else {
			typeNameMD = Qualname;
		}
	}

	//
	// Some characters may be present on types or methods and needs to be
	// sanitazed for markdown
	//
	static private string sanitizeStringMarkdown(string value) {
		value = value.Replace("<", "\\<");
		value = value.Replace(">", "\\>");
		value = value.Replace("[", "\\[");
		value = value.Replace("]", "\\]");
		value = value.Replace("(", "\\(");
		value = value.Replace(")", "\\)");
		value = value.Replace("#", "\\#");
		value = value.Replace("*", "\\*");
		value = value.Replace("_", "\\_");
		value = value.Replace("`", "\\`");
		value = value.Replace("!", "\\!");
		value = value.Replace("-", "\\-");
		value = value.Replace("+", "\\+");
		value = value.Replace(".", "\\.");
		value = value.Replace("~", "\\~");
		value = value.Replace("|", "\\|");
		value = value.Replace("{", "\\{");
		value = value.Replace("}", "\\}");
		return value;
	}
	//
	// Filter by namespace.
	// Receives the namespace path and the name of the object
	// Returns true if the object should be discarded
	// false if the object should be included
	//
	static private bool filterByNamespace(string path, string name) {
		//
		// We need to filter out by namespace and by file location
		// So, first, discard by namespace
		//
		//
		if (path == String.Empty) {
			// If the object does not have a path, it's a root namespace
			if (Namespaces.Contains(name) == false) {
				//Console.WriteLine("Discarding: " + name + " Path: " + path);
				return true;
			}
		} else {
			if (Namespaces.Any(o => path.StartsWith(o)) == false) {
				//Console.WriteLine("Discarding: " + name + " Path: " + path);
				return true;
			}
		}
		return false;
	}

	//
	// Filter by file path
	// If file path is not empty, it will be included if it contains any of the paths in the Paths array
	//
	static private bool filterByFilePath(string file) {
		if (file == String.Empty) {
			// If the file provided is empty it may belong to global definition or namespace that has no file related
			return false;
		}
		//
		// Filter by file path
		//
		if (Paths.Any(o => file.Contains(o)) == false) {
			//Console.WriteLine("Discarding: " + file);
			return true;
		}
		return false;
	}
}


